import Mathlib.Data.Finset.Sort
import Mathlib.Data.Nat.Basic
import Mathlib.Data.Set.Basic
import Mathlib.Init.Order.Defs
import Mathlib.Init.Set
import Mathlib.Tactic.LibrarySearch
import Mathlib.Data.FinEnum

/- Some utilities to clarify & simplify definitions. -/
section Utils

/--
  A notation for vectors.

  A definition cannot be used as inductive constructors can't contain `def`s.
-/
notation "Vec" => (fun (n : ‚Ñï) (Œ± : Type) => Fin n ‚Üí Œ±)

instance : FinEnum Bool := ‚ü®
  -- card
  2,
  -- mappings between Bool and Fin 2
  (fun b => if b then 1 else 0),
  (fun i => if i = 0 then false else true),
  -- proofs that above maps are inverses of each other
  (by simp only),
  (by simp only)
‚ü©

end Utils

/-- A symbol of arity `n`. -/
structure Symbol (n : ‚Ñï) where
  repr : String
  fn : Vec n Bool ‚Üí Bool

/--
  The signature (symbols) of a propositional language.

  This is modeled as a family of sets of functions with different arities.
  Constants are `Signature.symbols 0`.
-/
structure Signature where
  /-- Symbols with arity `n`. -/
  symbols : (n : ‚Ñï) ‚Üí Set (Symbol n)

/-- Constructs signatures with symbols of arity `1` and `2`. -/
def Signature.mk‚ÇÅ‚ÇÇ (u : Set (Symbol 1)) (b : Set (Symbol 2)) :=
  Signature.mk (fun
    | 1 => u
    | 2 => b
    | _ => ‚àÖ
  )

/--
  Formulas for a given signature with at most `n` unbound variables.
-/
inductive Signature.Formula {S : Signature} (n : ‚Ñï) where
  /-- Unbound variables. -/
  | var : (Fin n) ‚Üí S.Formula n
  /-- Application. Constants are applications of arity `0`. -/
  | apply : (f : _) ‚Üí (f ‚àà S.symbols a) ‚Üí Vec a (S.Formula n) ‚Üí S.Formula n

instance {S : Signature} : ToString (S.Formula n) :=
  let rec toString (œÜ : S.Formula n) : String :=
    match œÜ with
    | Signature.Formula.var i => s!"x_{i}"
    | @Signature.Formula.apply _ _ a f _ œàs =>
      match a with
      -- constants are just the symbols
      | 0 => s!"{f.1}"
      -- unary operators do not surround their arguments
      | 1 => s!"{f.1}{toString (œàs 0)}"
      -- operators of arity `n > 1` surround their arguments in brackets (`[]`)
      | k+2 =>
        have a_pos : k+2 > 0 := by simp only [gt_iff_lt, add_pos_iff, or_true]
        let params := (List.range (k+2)).map (fun i => toString (œàs (@Fin.ofNat' (k+2) i a_pos)))
        s!"{f.1}{params}"
  
  ‚ü®toString‚ü©

/--
  The _valuation_ of a formula is the boolean function it represents.
-/
@[reducible]
def Signature.Formula.value {S : Signature} {œÜ : S.Formula n} (vars : Vec n Bool) : Bool :=
  match œÜ with
  | var i => vars i
  | apply f _ œàs => f.2 (fun i => (œàs i).value vars)

/--
  Sentences for a given signature are formulas with no unbound variables.
-/
def Signature.Sentence {S : Signature} := S.Formula 0

/--
  A signature is _functional complete_ if any function of any arity is
  representable by some formula.
-/
def Signature.functional_complete {S : Signature} : Prop :=
  ‚àÄ {n} (f : Vec n Bool ‚Üí Bool), ‚àÉ (œÜ : S.Formula n), f = œÜ.value

/--
  A signature `S‚ÇÅ` is a subset of a signature `S‚ÇÇ` if the symbols
  in `S‚ÇÅ` are also in `S‚ÇÇ`.
-/
def Signature.subset (S‚ÇÅ S‚ÇÇ : Signature) : Prop :=
  ‚àÄ (n : ‚Ñï), S‚ÇÅ.symbols n ‚äÜ S‚ÇÇ.symbols n

/--
  A signature `S‚ÇÅ` is _subsumes_ a signature `S‚ÇÇ` if every formula
  `œÜ` of signature `S‚ÇÇ` can be represented by a formula `œà` of signature `S‚ÇÅ`.
-/
@[simp]
def Signature.subsumes (S‚ÇÅ S‚ÇÇ : Signature) : Prop :=
  ‚àÄ {n} (œÜ : S‚ÇÇ.Formula n), ‚àÉ œà : S‚ÇÅ.Formula n, œÜ.value = œà.value

/--
  Embeds a formula `œÜ` of a signature `S‚ÇÅ` into a signature `S‚ÇÇ` assuming `S‚ÇÅ ‚äÜ S‚ÇÇ`. 
-/
@[simp, reducible]
def Signature.embed {S‚ÇÅ S‚ÇÇ : Signature} (hs : S‚ÇÅ.subset S‚ÇÇ) (œÜ : S‚ÇÅ.Formula n) : S‚ÇÇ.Formula n :=
  match œÜ with
  | Formula.var i => Formula.var i
  | Formula.apply f hf œàs =>
    Formula.apply f
      (Set.mem_of_subset_of_mem (hs _) hf)
      (fun i => embed hs (œàs i))

/--
  If signature `S‚ÇÅ` is a subset of signature `S‚ÇÇ`, then `S‚ÇÇ` subsumes `S‚ÇÅ`.
-/
def Signature.subset_subsumes {S‚ÇÅ S‚ÇÇ : Signature} (hs : S‚ÇÅ.subset S‚ÇÇ) :
  S‚ÇÇ.subsumes S‚ÇÅ := by
    intro n œÜ
    let œà := embed hs œÜ
    have h : œÜ.value = (embed hs œÜ).value := by
      funext vars
      induction œÜ
      ¬∑ rfl
      ¬∑ rename_i a f hf œÜs hœÜs
        have hœÜ : (Formula.apply f hf œÜs).value vars = f.2 (fun i => (œÜs i).value vars) := rfl
        have hœà : œà.value vars = f.2 (fun i => (embed hs (œÜs i)).value vars) := rfl
        rw [hœÜ, hœà, funext hœÜs]
    
    exact ‚ü®œà, h‚ü©


/--
  If a signature `S‚ÇÅ` can subsume a functional complete signature `S‚ÇÇ`, then
  `S‚ÇÅ` is also functional complete.
-/
theorem Signature.subsumes_functional_complete {S‚ÇÅ S‚ÇÇ : Signature} (hfc : S‚ÇÅ.functional_complete) (hs : S‚ÇÇ.subsumes S‚ÇÅ) :
  S‚ÇÇ.functional_complete := by
  intro n f
  have ‚ü®œÜ, hœÜ‚ü© := hfc f
  have ‚ü®œà, hœà‚ü© := hs œÜ
  rw [hœÜ.symm] at hœà
  exact ‚ü®œà, hœà‚ü©

/--
  If a signature `S‚ÇÅ` is the subset of a functional complete signature `S‚ÇÇ`, then
  `S‚ÇÅ` is also functional complete.
-/
theorem Signature.subset_functional_complete {S‚ÇÅ S‚ÇÇ : Signature} (hfc : S‚ÇÅ.functional_complete) (hs : S‚ÇÅ.subset S‚ÇÇ) :
  S‚ÇÇ.functional_complete := by
  have hr : S‚ÇÇ.subsumes S‚ÇÅ := S‚ÇÅ.subset_subsumes hs
  exact @subsumes_functional_complete S‚ÇÅ S‚ÇÇ hfc hr

def not' : Vec 1 Bool ‚Üí Bool := (fun p => ¬¨ (p 0))
def or' : Vec 2 Bool ‚Üí Bool := (fun p => (p 0) ‚à® (p 1))
def and' : Vec 2 Bool ‚Üí Bool := (fun p => (p 0) ‚àß (p 1))
def bigor' (n : ‚Ñï) : Vec n Bool ‚Üí Bool := (fun p => ‚àÉ i, p i)
def bigand' (n : ‚Ñï) : Vec n Bool ‚Üí Bool := (fun p => ‚àÄ i, p i)

notation "(¬¨)" => Symbol.mk "¬¨" not'
notation "(‚à®)" => Symbol.mk "‚à®" or'
notation "(‚àß)" => Symbol.mk "‚àß" and'
notation "‚ãÅ" => (fun n => Symbol.mk "‚ãÅ" (bigor' n))
notation "‚ãÄ" => (fun n => Symbol.mk "‚ãÄ" (bigand' n))

/--
  The signature `{¬¨} ‚à™ {‚ãÅ n : n ‚àà ‚Ñï} ‚à™ {‚ãÄ n : n ‚àà ‚Ñï} `.
  
  This includes the big-or and big-and operators for every arity `n`, as they
  are used for constructing DNFs and CNFs of boolean functions.
-/
@[simp]
def sig_nOA := Signature.mk (fun
  | 1 => {‚ãÅ 1, ‚ãÄ 1, (¬¨)}
  | n => {‚ãÅ n, ‚ãÄ n}
)

lemma sig_nOA_not : (¬¨) ‚àà sig_nOA.symbols 1 := by
  simp only [sig_nOA, Set.mem_singleton_iff, Symbol.mk.injEq, Set.mem_insert_iff, or_self, false_and, or_true]

lemma sig_nOA_Or {n : ‚Ñï} : (‚ãÅ n) ‚àà sig_nOA.symbols n := by
  match n with
  | 0 => simp only [sig_nOA, Set.mem_singleton_iff, Set.mem_insert_iff, true_or]
  | 1 => simp only [sig_nOA, Set.mem_singleton_iff, Set.mem_insert_iff, true_or, or_true]
  | n+2 => simp only [sig_nOA, Set.mem_singleton_iff, Set.mem_insert_iff, Nat.add_eq, Nat.add_zero, true_or]

lemma sig_nOA_And {n : ‚Ñï} : (‚ãÄ n) ‚àà sig_nOA.symbols n := by
  match n with
  | 0 => simp only [sig_nOA, Set.mem_singleton_iff, Set.mem_insert_iff, or_true]
  | 1 => simp only [sig_nOA, Set.mem_singleton_iff, Set.mem_insert_iff, true_or, or_true]
  | n+2 => simp only [sig_nOA, Set.mem_singleton_iff, Set.mem_insert_iff, Nat.add_eq, Nat.add_zero, or_true]

/--
  A list of inputs satisfying `f`.
  
  That is, a list of `b : Vec n Bool` such that `f b = true`. This list is
  ordered by the ordering imposed by `FinEnum Bool`.
-/
def satisfying_inputs (f : Vec n Bool ‚Üí Bool) : List (Vec n Bool) :=
  (FinEnum.pi.enum (fun _ => Bool)).filter f

/-- If `f b = true` then `b` is in the list of satisfying inputs. -/
def satisfying_inputs_contains (f : Vec n Bool ‚Üí Bool) (b : Vec n Bool) (hb : f b = true) :
  ‚àÉ i, (satisfying_inputs f).get i = b := 
  List.mem_iff_get.mp (List.mem_filter.mpr ‚ü®FinEnum.pi.mem_enum _, hb‚ü©)

/--
  The conjunctive gadget (a DNF entry) used to construct a DNF for a boolean
  function.

  If `b` is an `n`-tuple, then `dnf_entry` produces a formula of arity `n`,
  `œÜ(x‚ÇÅ, .., x‚Çô) = ‚ãÄ·µ¢‚Çå‚ÇÅ..‚Çô (if b·µ¢ then x·µ¢ else ¬¨x·µ¢)`. Each of these conjunctions
  are then disjuncted to produce a DNF.

  Technically this conjunction can live in a signature `{¬¨, ‚ãÄ}`, but it is in
  the signature `{¬¨, ‚àß, ‚à®, ‚ãÄ, ‚ãÅ}` to simplify the construction of the DNF.
-/
def dnf_entry (b : Vec n Bool) : sig_nOA.Formula n :=
  Signature.Formula.apply (‚ãÄ n) sig_nOA_And (fun i =>
    if b i then
      (Signature.Formula.var i)
    else
      (Signature.Formula.apply (¬¨) sig_nOA_not (fun _ => Signature.Formula.var i))
  )

/--
  The conjunctive gadget (a DNF entry) evaluates to true for the boolean vector
  `b` that was used to build it.
-/
lemma dnf_entry_true (b : Vec n Bool) : (dnf_entry b).value b = true := by
  simp only [Signature.Formula.value, bigand', decide_eq_true_eq]
  intro i
  by_cases b i = true
  all_goals { simp only [Signature.Formula.value, *] }

/--
  If a conjunctive gadget (a DNF entry) constructed from a boolean vector `b‚ÇÅ`
  evaluates to true for some boolean vector `b‚ÇÇ`, then `b‚ÇÅ = b‚ÇÇ`.
-/
lemma dnf_entry_true_eq (b‚ÇÅ b‚ÇÇ : Vec n Bool) : (dnf_entry b‚ÇÅ).value b‚ÇÇ = true ‚Üí b‚ÇÅ = b‚ÇÇ := by
  intro h
  funext i
  simp [Signature.Formula.value, dnf_entry, bigand', *] at h
  have hœÜb‚ÇÇ := h i
  by_cases b‚ÇÅ i = true
  all_goals {
    simp [Signature.Formula.value, dnf_entry, bigand', not', *] at hœÜb‚ÇÇ
    try rw [Bool.not_eq_true] at h
    rw [h]
    exact hœÜb‚ÇÇ.symm
  }

/--
  The disjunctive normal form (DNF) of a boolean function `f` of arity `n`.

  This requires `‚àÄ (b : Vec n Prop), Decidable (f b)` in order to
  constructively produce a formula `œÜ` that represents `f`.
-/
def dnf (f : Vec n Bool ‚Üí Bool) : sig_nOA.Formula n :=
  have trues := satisfying_inputs f

  Signature.Formula.apply (‚ãÅ trues.length) sig_nOA_Or (dnf_entry ‚àò trues.get)

/--
  For any function `f: ùîπ‚Åø ‚Üí ùîπ`, the DNF of `f` represents `f`.
-/
theorem dnf_represents (f : Vec n Bool ‚Üí Bool) : (dnf f).value = f := by
  funext b
  rw [Signature.Formula.value]
  simp only [bigor']
  by_cases (f b)

  -- f b = true
  ¬∑ rw [h]
    simp only [Bool.true_eq_decide_iff, bigand', decide_eq_true_eq]
    have ‚ü®i, hi‚ü© := satisfying_inputs_contains f b h
    apply Exists.intro i
    rw [Function.comp_apply, hi]
    exact dnf_entry_true b

  -- f b = false
  ¬∑ rw [Bool.not_eq_true] at h
    rw [h]
    simp only [
      Bool.false_eq_decide_iff, bigand', decide_eq_false_iff_not,
      not_exists, not_forall, Bool.not_eq_true, Function.comp_apply
    ]
    intro i
    apply by_contradiction
    intro hœÜb_true
    let b·µ¢ := (satisfying_inputs f).get i
    have hfb·µ¢ : f b·µ¢ = true := (List.mem_filter.mp (List.get_mem _ i _)).2
    rw [Bool.not_eq_false] at hœÜb_true
    rw [dnf_entry_true_eq b·µ¢ b hœÜb_true, h] at hfb·µ¢
    contradiction

/--
  The signature `{¬¨, ‚à®, ‚àß, ‚ãÅ, ‚ãÄ}` is functional complete.
-/
theorem sig_nOA_functional_complete : sig_nOA.functional_complete := by
  intro n f
  exact ‚ü®dnf f, (dnf_represents f).symm‚ü©

def sig_noa := Signature.mk‚ÇÅ‚ÇÇ {(¬¨)} {(‚à®), (‚àß)}
def sig_no := Signature.mk‚ÇÅ‚ÇÇ {(¬¨)} {(‚à®)}
def sig_na := Signature.mk‚ÇÅ‚ÇÇ {(¬¨)} {(‚àß)}

theorem sig_noa_subsumes_nOA : sig_noa.subsumes sig_nOA := by
  intro n œÜ

  let rec embed (œÜ : sig_nOA.Formula n) : sig_noa.Formula n :=
    match œÜ with
    | Signature.Formula.var i => Signature.Formula.var i
    | Signature.Formula.apply a f hf œÜs => match a with
      | 0 => by
        have : f = (‚ãÅ 0) := hf
        exact 
      | 1 => by
        have : f = (¬¨) ‚à® f = (‚ãÅ 1) := hf
      | 2 => sorry
      | n => sorry

  let œà := embed œÜ
  have hœà : œÜ.value = œà.value := sorry
  
  exact ‚ü®œà, hœà‚ü© 

/--
  Theorem 2.1 from Chapter 1.

  The signature `{¬¨, ‚àß, ‚à®}` is functional complete.
-/
theorem sig_noa_functional_complete : sig_noa.functional_complete :=
  Signature.subsumes_functional_complete sig_nOA_functional_complete sig_noa_subsumes_nOA